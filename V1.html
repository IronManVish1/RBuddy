<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummy Buddy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary-light: #f0f2f5; --text-primary-light: #1f2937; --text-secondary-light: #4b5563; --card-bg-light: #ffffff; --border-light: #e0e0e0; --header-text-light: #1976d2; --input-bg-light: #f5f5f5; --input-border-light: #bdbdbd; --input-text-light: #212121; --btn-primary-bg-light: #1976d2; --btn-secondary-bg-light: #607d8b; --link-light: #1976d2; --text-muted-light: #6b7280;
            --bg-primary-dark: #111827; --text-primary-dark: #f3f4f6; --text-secondary-dark: #9ca3af; --card-bg-dark: #1f2937; --border-dark: #374151; --header-text-dark: #60a5fa; --input-bg-dark: #374151; --input-border-dark: #4b5563; --input-text-dark: #f3f4f6; --btn-primary-bg-dark: #2563eb; --btn-secondary-bg-dark: #4b5563; --link-dark: #60a5fa; --text-muted-dark: #9ca3af;
        }
        body { font-family: 'Inter', sans-serif; transition: background-color 0.3s, color 0.3s; }
        body.light-theme { background-color: var(--bg-primary-light); color: var(--text-primary-light); }
        body.dark-theme { background-color: var(--bg-primary-dark); color: var(--text-primary-dark); }
        .app-container { border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); transition: background-color 0.3s; }
        body.light-theme .app-container { background-color: var(--card-bg-light); }
        body.dark-theme .app-container { background-color: var(--card-bg-dark); }
        header h1 { transition: color 0.3s; }
        body.light-theme header h1 { color: var(--header-text-light); }
        body.dark-theme header h1 { color: var(--header-text-dark); }
        header h1.navigable:hover { text-decoration: underline; cursor: pointer; }
        .section-card { border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); transition: background-color 0.3s, border-color 0.3s; }
        body.light-theme .section-card { background-color: var(--card-bg-light); border: 1px solid var(--border-light); }
        body.dark-theme .section-card { background-color: var(--card-bg-dark); border: 1px solid var(--border-dark); }
        body.light-theme .section-card h2, body.light-theme .section-card h3, body.light-theme .section-card label, body.light-theme .section-card legend { color: var(--text-primary-light); }
        body.dark-theme .section-card h2, body.dark-theme .section-card h3, body.dark-theme .section-card label, body.dark-theme .section-card legend { color: var(--text-primary-dark); }
        body.light-theme .section-card .text-muted { color: var(--text-muted-light); } 
        body.dark-theme .section-card .text-muted { color: var(--text-muted-dark); }
        .modal { display: none; position: fixed; inset: 0; align-items: center; justify-content: center; padding: 1rem; z-index: 50; }
        .modal.active { display: flex; background-color: rgba(0,0,0,0.6); }
        .modal-content { border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); transition: background-color 0.3s; width:100%; }
        body.light-theme .modal-content { background-color: var(--card-bg-light); }
        body.dark-theme .modal-content { background-color: var(--card-bg-dark); }
        body.light-theme .modal-content h3 { color: var(--text-primary-light); }
        body.dark-theme .modal-content h3 { color: var(--text-primary-dark); }
        ::-webkit-scrollbar { width: 8px; }
        body.light-theme ::-webkit-scrollbar-track { background: #e0e0e0; }
        body.dark-theme ::-webkit-scrollbar-track { background: #2d3748; } 
        body.light-theme ::-webkit-scrollbar-thumb { background: #90a4ae; border-radius: 4px; }
        body.dark-theme ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
        body.light-theme ::-webkit-scrollbar-thumb:hover { background: #78909c; }
        body.dark-theme ::-webkit-scrollbar-thumb:hover { background: #718096; }
        input[type="text"], input[type="number"] { border-radius: 9999px; padding: 0.65rem 1rem; transition: background-color 0.3s, border-color 0.3s, color 0.3s; width: 100%; }
        body.light-theme input[type="text"], body.light-theme input[type="number"] { background-color: var(--input-bg-light); border: 1px solid var(--input-border-light); color: var(--input-text-light); }
        body.dark-theme input[type="text"], body.dark-theme input[type="number"] { background-color: var(--input-bg-dark); border: 1px solid var(--input-border-dark); color: var(--input-text-dark); }
        body.light-theme input[type="text"]:focus, body.light-theme input[type="number"]:focus { border-color: var(--btn-primary-bg-light); box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2); }
        body.dark-theme input[type="text"]:focus, body.dark-theme input[type="number"]:focus { border-color: var(--btn-primary-bg-dark); box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3); }
        .btn { border-radius: 9999px; padding: 0.65rem 1.25rem; font-weight: 500; transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, color 0.2s ease-in-out, transform 0.1s ease-out, filter 0.1s ease-out; text-transform: uppercase; letter-spacing: 0.05em; border: none; display: inline-flex; align-items: center; justify-content: center; }
        .btn:active {
            transform: scale(0.96);
            filter: brightness(0.9);
        }
        .btn-sm { padding: 0.4rem 0.8rem; font-size: 0.75rem; } 
        .btn-primary { color: white; }
        body.light-theme .btn-primary { background-color: var(--btn-primary-bg-light); }
        body.dark-theme .btn-primary { background-color: var(--btn-primary-bg-dark); }
        .btn-primary:hover { box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        body.light-theme .btn-primary:hover { background-color: #1565c0; }
        body.dark-theme .btn-primary:hover { background-color: #1e40af; }
        .btn-secondary { color: white; }
        body.light-theme .btn-secondary { background-color: var(--btn-secondary-bg-light); }
        body.dark-theme .btn-secondary { background-color: var(--btn-secondary-bg-dark); }
        .btn-secondary:hover { box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        body.light-theme .btn-secondary:hover { background-color: #546e7a; }
        body.dark-theme .btn-secondary:hover { background-color: #374151; }
        .btn-success { background-color: #4caf50; color: white; }
        .btn-success:hover { background-color: #43a047; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .btn-danger { background-color: #d32f2f; color: white; }
        .btn-danger:hover { background-color: #c62828; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .btn-warning { background-color: #ff9800; color: white; }
        .btn-warning:hover { background-color: #fb8c00; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .btn-text { background-color: transparent; font-weight: 500; padding: 0.5rem 0.75rem; border-radius: 9999px; }
        body.light-theme .btn-text-danger { color: #d32f2f; }
        body.dark-theme .btn-text-danger { color: #f87171; } 
        .btn-text-danger:hover { background-color: rgba(211, 47, 47, 0.1); }
        body.light-theme .btn-text-green { color: #4caf50; }
        body.dark-theme .btn-text-green { color: #68d391; } 
        .btn-text-green:hover { background-color: rgba(76, 175, 80, 0.1); }
        body.light-theme .btn-text-blue { color: var(--link-light); }
        body.dark-theme .btn-text-blue { color: var(--link-dark); }
        .btn-text-blue:hover { background-color: rgba(25, 118, 210, 0.1); }

        #knownPlayersList button.btn-secondary {
            text-transform: none;
        }

        .known-player-delete-btn {
            display: inline-flex !important;
            visibility: visible !important;
            text-transform: none !important;
            font-size: 0.75rem !important;    /* text-xs */
            line-height: 1rem !important;     /* lineheight for text-xs */
            padding: 0.1rem 0.25rem !important; /* minimal effective padding */
            /* Color is intended to be handled by .btn-text-danger and its theme overrides */
        }
        .score-option-btn { font-size: 0.75rem; padding: 0.35rem 0.6rem; border: 1px solid; border-radius: 9999px; }
        body.light-theme .score-option-btn { background-color: #e0e0e0; color: #374151; border-color: #bdbdbd; }
        body.dark-theme .score-option-btn { background-color: #4b5563; color: #e5e7eb; border-color: #6b7280; }
        body.light-theme .score-option-btn:hover { background-color: #cccccc; }
        body.dark-theme .score-option-btn:hover { background-color: #6b7280; }
        .saved-game-item { transition: background-color 0.3s, border-color 0.3s; }
        body.light-theme .saved-game-item { border-left: 4px solid var(--btn-primary-bg-light); background-color: #fafafa; }
        body.dark-theme .saved-game-item { border-left: 4px solid var(--btn-primary-bg-dark); background-color: #2d3748; }
        body.light-theme .saved-game-item.completed-game { border-left-color: #d32f2f; background-color: #ffebee; }
        body.dark-theme .saved-game-item.completed-game { border-left-color: #e53e3e; background-color: #4a2e2e; }
        body.light-theme .saved-game-item p { color: var(--text-secondary-light); } 
        body.dark-theme .saved-game-item p { color: var(--text-secondary-dark); }
        body.light-theme .saved-game-item .game-name-link { color: var(--link-light); font-weight: 500; }
        body.dark-theme .saved-game-item .game-name-link { color: var(--link-dark); font-weight: 500; }
        body.light-theme .saved-game-item .text-muted { color: var(--text-muted-light); }
        body.dark-theme .saved-game-item .text-muted { color: var(--text-muted-dark); }
        table { width: 100%; border-collapse: collapse; }
        th, td { text-align: left; padding: 0.75rem; font-size: 0.875rem; transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        body.light-theme th, body.light-theme td { border-bottom: 1px solid var(--border-light); }
        body.dark-theme th, body.dark-theme td { border-bottom: 1px solid var(--border-dark); }
        body.light-theme th { background-color: #f5f5f5; color: #424242; font-weight: 600; }
        body.dark-theme th { background-color: #2d3748; color: #cbd5e0; font-weight: 600; }
        body.light-theme td { color: var(--text-primary-light); } 
        body.dark-theme td { color: var(--text-primary-dark); }
        body.light-theme tbody tr:last-child td, body.light-theme tfoot tr:last-child td { border-bottom: none; }
        body.dark-theme tbody tr:last-child td, body.dark-theme tfoot tr:last-child td { border-bottom: none; }
        body.light-theme tbody tr:hover { background-color: #f0f0f0; } 
        body.dark-theme tbody tr:hover { background-color: #252f3e; }
        body.light-theme tfoot td { font-weight: 600; background-color: #eeeeee; }
        body.dark-theme tfoot td { font-weight: 600; background-color: #252f3e; }
        #themeToggle { cursor: pointer; padding: 0.5rem; border-radius: 50%; transition: background-color 0.2s; }
        body.light-theme #themeToggle:hover { background-color: rgba(0,0,0,0.1); }
        body.dark-theme #themeToggle:hover { background-color: rgba(255,255,255,0.1); }
        body.light-theme #themeToggle svg { stroke: var(--text-primary-light); }
        body.dark-theme #themeToggle svg { stroke: var(--text-primary-dark); }
        #autoSaveNotification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 9999px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); font-size: 0.9rem; z-index: 100; opacity: 0; transition: opacity 0.5s ease-in-out, background-color 0.3s, color 0.3s; }
        body.light-theme #autoSaveNotification { background-color: #212121; color: white; }
        body.dark-theme #autoSaveNotification { background-color: #f0f2f5; color: #1f2937; }
        #autoSaveNotification.show { opacity: 1; }
        .loader { border: 3px solid #ecf0f1; border-top: 3px solid #5dade2; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; display: inline-block; margin-left: 8px;}
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Initial state for sections that will animate in */
        .section-animate-initial {
            opacity: 0;
            transform: translateX(20px); /* Slide in from right */
        }

        /* Class to apply to make a section enter (fade and slide in) */
        .section-is-entering {
            opacity: 1 !important;
            transform: translateX(0) !important;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        /* Class to apply to make a section exit (fade and slide out) */
        .section-is-exiting {
            opacity: 0 !important;
            transform: translateX(-20px) !important; /* Slide out to left */
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        @keyframes highlight-new-row {
            0% {
                background-color: rgba(255, 255, 0, 0.5); /* Light yellow, semi-transparent */
            }
            70% { /* Hold highlight for a bit */
                background-color: rgba(255, 255, 0, 0.3);
            }
            100% {
                background-color: transparent; /* Fade to transparent */
            }
        }

        .new-score-row-highlight > td { /* Apply to TDs for better background control */
            animation: highlight-new-row 1.5s ease-out;
        }

@keyframes flash-eliminated-player-cell {
    0% {
        background-color: rgba(211, 47, 47, 0.6); /* Semi-transparent danger red */
    }
    50% {
        background-color: rgba(211, 47, 47, 0.3); /* Dimmer highlight */
    }
    100% {
        background-color: transparent; /* Fade to transparent */
    }
}

.player-just-eliminated-animation { /* This class will be applied to a <td> */
    animation: flash-eliminated-player-cell 1.5s ease-out;
}

/* Animation for Winner Message */
@keyframes animate-winner-message {
    0% {
        opacity: 0;
        transform: scale(0.9) translateY(10px);
    }
    100% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

.winner-message-animate {
    animation: animate-winner-message 0.5s ease-out forwards;
}

/* Styling for Winner's Cells in Table Footer */
body.light-theme .winner-highlight-cell { /* Applied to <td> */
    background-color: rgba(255, 215, 0, 0.3) !important; /* Light gold, semi-transparent */
}

body.dark-theme .winner-highlight-cell { /* Applied to <td> */
    background-color: rgba(255, 215, 0, 0.4) !important; /* Slightly more opaque gold for dark theme */
}

/* Winner Celebration Overlay */
.winner-celebration-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    z-index: 1000;
}

.particle {
    position: absolute;
    top: -20px; /* Start above the screen */
    opacity: 1;
    will-change: transform, opacity; /* Performance hint */
}

/* Confetti Shapes */
.confetti {
    width: 8px;
    height: 8px;
    border-radius: 2px; /* Slightly rounded square */
}
.confetti.circle {
    border-radius: 50%;
}

/* Streamer Shape */
.streamer {
    width: 6px;
    height: 100px; /* Long and thin */
    border-radius: 3px;
}

/* Colors (can be expanded) */
.color-red { background-color: #e74c3c; }
.color-yellow { background-color: #f1c40f; }
.color-blue { background-color: #3498db; }
.color-green { background-color: #2ecc71; }
.color-purple { background-color: #9b59b6; }
.color-orange { background-color: #e67e22; }


/* Animations */
@keyframes fall-and-fade {
    0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
    }
    100% {
        transform: translateY(110vh) rotate(720deg); /* Fall below screen, rotate a bit */
        opacity: 0;
    }
}

/* Applying animation - duration and delay will be varied by JS or multiple classes */
.animate-fall-1 { animation: fall-and-fade 3s linear forwards; }
.animate-fall-2 { animation: fall-and-fade 4s linear forwards; }
.animate-fall-3 { animation: fall-and-fade 5s linear forwards; }

@media (max-width: 480px) {
    .score-option-btn {
        padding: 0.2rem 0.2rem !important;   /* Adjusted for slightly more horizontal padding based on typical 'X' character width vs text */
        font-size: 0.6rem !important;
        line-height: 0.75rem !important;
        letter-spacing: -0.5px;
        min-width: 48px;  /* Approx width for "Mid (40)" with tiny font/padding */
        word-break: break-word;
        white-space: normal;
        text-align: center; /* Center text if it wraps */
        /* Ensure border is minimal or accounted for if it adds width */
        border-width: 1px; /* Assuming it has a border, ensure it's minimal */
    }
}

     .logo-icon { /* This is the span wrapping the SVG */
        line-height: 1em; /* Helps with vertical alignment if SVG is display:inline-block */
     }
     .logo-icon svg {
         display: inline-block; /* Ensure it behaves well with text */
         width: 1em; /* Scale with the font size of the parent h1 */
         height: 1em;
         margin-left: 0.2em; /* Small gap */
         margin-right: 0.2em; /* Small gap */
         vertical-align: -0.12em; /* Adjust to align SVG baseline with text baseline */
         /* transform: translateY(0.05em); */ /* Using vertical-align instead */
     }

     /* Footer Styling */
     body.light-theme #appFooter {
         border-color: var(--border-light);
         color: var(--text-secondary-light);
     }

     body.dark-theme #appFooter {
         border-color: var(--border-dark);
         color: var(--text-secondary-dark);
     }
    </style>
</head>
<body>
    <div class="app-container w-full max-w-4xl mx-auto p-4 md:p-8">
        <header class="mb-10 flex justify-between items-center">
            <h1 id="appTitle" class="text-3xl md:text-4xl font-bold flex items-center justify-center">
                <span>Rummy</span>
                <span class="logo-icon inline-block">
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" class="w-full h-full">
                        <path d="M 50,95 C 20,65 0,45 0,25 C 0,5 20,0 50,25 C 80,0 100,5 100,25 C 100,45 80,65 50,95" fill="currentColor"/>
                        <text x="50" y="65" font-family="sans-serif" font-weight="700" font-size="50" fill="white" text-anchor="middle">13</text>
                    </svg>
                </span>
                <span>Buddy</span>
            </h1>
            <div id="themeToggle" title="Toggle Theme"></div>
        </header>

        <section id="setupSection" class="section-card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-6">Game Setup</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div>
                    <label for="playerNameInput" class="block text-sm font-medium mb-1">Add New Player:</label>
                    <input type="text" id="playerNameInput" placeholder="Enter player name">
                </div>
                <button id="addPlayerButton" class="btn btn-primary self-end h-fit">Add Player</button>
            </div>
            <div class="mb-6">
                <h3 class="text-lg font-medium mb-2">Or Select Known Players:</h3>
                <div id="knownPlayersList" class="flex flex-wrap gap-2"></div>
            </div>
            <div class="mb-8">
                <h3 class="text-lg font-medium mb-2">Players for New Game:</h3>
                <div id="playerSetupList" class="flex flex-wrap gap-1"></div>
            </div>
            <fieldset class="mb-8 border p-4 rounded-md">
                <legend class="text-lg font-medium px-2">New Game Settings</legend>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4 mt-2">
                    <div><label for="gameTargetScoreInput" class="block text-sm font-medium mb-1">Game Target Score:</label><input type="number" id="gameTargetScoreInput" value="201"></div>
                    <div><label for="openDropScoreInput" class="block text-sm font-medium mb-1">Open Drop Points:</label><input type="number" id="openDropScoreInput" value="20"></div>
                    <div><label for="middleDropScoreInput" class="block text-sm font-medium mb-1">Middle Drop Points:</label><input type="number" id="middleDropScoreInput" value="40"></div>
                    <div><label for="fullCountScoreInput" class="block text-sm font-medium mb-1">Full Count Points:</label><input type="number" id="fullCountScoreInput" value="80"></div>
                </div>
            </fieldset>
            <button id="startNewGameButton" class="btn btn-success w-full text-base py-3 mb-8">Start New Game</button>
            <div>
                <h3 class="text-xl font-semibold mb-4">Saved Games</h3>
                <div id="savedGamesContainer" class="space-y-3 max-h-96 overflow-y-auto pr-2"></div>
            </div>
        </section>

        <section id="gameSection" class="hidden section-card p-6">
            <div class="flex flex-wrap justify-between items-center mb-3 gap-2">
                <div class="flex items-center gap-2">
                    <h2 id="currentGameNameDisplay" class="text-xl md:text-2xl font-semibold">Scoreboard</h2>
                    <div id="nameSuggestionLoader" class="loader hidden"></div>
                </div>
                <p class="text-md md:text-lg">Round: <span id="currentRoundDisplay" class="font-bold">0</span></p>
            </div>
            <div class="mb-1 text-sm text-muted">Target: <span id="gameTargetScoreDisplay" class="font-semibold"></span></div>
            <div class="mb-6 text-xs text-muted">
                Drops: Open (OD) <span id="gameOpenDropDisplay" class="font-semibold"></span> | Middle (MD) <span id="gameMiddleDropDisplay" class="font-semibold"></span> | Full Count (FC) <span id="gameFullCountDisplay" class="font-semibold"></span> | Dealer: (D)
            </div>
            <div class="mb-8">
                <h3 class="text-lg font-semibold mb-3">Round-by-Round Scores & Status</h3>
                <div id="roundScoresTableContainer" class="overflow-x-auto rounded-lg border dark:border-gray-700"></div>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4"> 
                <button id="enterScoresButton" class="btn btn-primary">Enter Scores</button>
                <button id="editLastRoundButton" class="btn btn-warning">Edit Last Round</button> 
            </div>
            <div id="gameStatusMessage" class="mt-6 text-center text-xl font-semibold text-orange-600 dark:text-yellow-400"></div>
            <div id="autoSaveNotification">Auto-saved!</div>
        </section>
    </div>

    <div id="scoreModal" class="modal fixed inset-0 items-center justify-center p-4">
        <div class="modal-content p-6 w-full max-w-xl max-h-[90vh] flex flex-col">
            <h3 class="text-2xl font-semibold mb-6 text-center" id="scoreModalTitle">Enter Scores for Round <span id="modalRoundNumber"></span></h3>
            <div id="modalScoreInputs" class="space-y-5 overflow-y-auto mb-6 pr-2"></div>
            <div class="flex gap-3 mt-auto">
                <button id="submitScoresButton" class="btn btn-success flex-1">Submit Scores</button>
                <button id="cancelScoreEntryButton" class="btn btn-secondary flex-1">Cancel</button>
            </div>
        </div>
    </div>

    <footer id="appFooter" class="mt-12 pt-6 pb-2 text-center border-t">
        <p class="text-sm">Developed by "Your Vish"</p>
    </footer>
    <script>
        // DOM Elements - Declared globally, assigned in initializeApp
        let appTitle, setupSection, gameSection, playerNameInput, addPlayerButton, knownPlayersList, playerSetupList,
            gameTargetScoreInput, openDropScoreInput, middleDropScoreInput, fullCountScoreInput,
            startNewGameButton, savedGamesContainer, themeToggleButton, currentGameNameDisplay,
            nameSuggestionLoader, currentRoundDisplay, gameTargetScoreDisplay,
            gameOpenDropDisplay, gameMiddleDropDisplay, gameFullCountDisplay, roundScoresTableContainer,
            enterScoresButton, editLastRoundButton, gameStatusMessage, autoSaveNotification,
            scoreModal, scoreModalTitle, modalRoundNumber, modalScoreInputs, submitScoresButton, cancelScoreEntryButton;

        // Game State & Local Storage Keys
        let playersForNewGameSetup = [];
        let currentGame = null; 
        let isEditingLastRoundGlobal = false; 
        
        const LS_KNOWN_PLAYERS = 'rummyScorer_knownPlayers_v10_3'; 
        const LS_SAVED_GAMES_LIST = 'rummyScorer_savedGamesList_v10_3';
        const LS_THEME = 'rummyScorer_theme_v10_3';

        // Theme SVGs
        const sunIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-6.364-.386l1.591-1.591M3 12h2.25m.386-6.364l1.591 1.591M12 12a2.25 2.25 0 00-2.25 2.25c0 1.242.938 2.25 2.1 2.25s2.1-.938 2.1-2.25A2.25 2.25 0 0012 12z" /></svg>`;
        const moonIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" /></svg>`;

        function getStoredData(key) { try { const d = localStorage.getItem(key); return d ? JSON.parse(d) : null; } catch (e) { console.error("LS Read Error:", key, e); return null; } }
        function setStoredData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error("LS Write Error:", key, e); alert("Could not save data. Storage might be full or disabled."); } }

        function applyTheme(theme) {
            document.body.classList.toggle('dark-theme', theme === 'dark');
            document.body.classList.toggle('light-theme', theme === 'light');
            if (themeToggleButton) themeToggleButton.innerHTML = theme === 'dark' ? sunIcon : moonIcon;
        }
        function toggleTheme() {
            const newTheme = document.body.classList.contains('dark-theme') ? 'light' : 'dark';
            applyTheme(newTheme);
            setStoredData(LS_THEME, newTheme);
        }
        function loadTheme() { applyTheme(getStoredData(LS_THEME) || 'light'); }

function getFormattedEstDate(date = new Date(), includeTime = false) {
    try {
        const options = {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            timeZone: 'America/New_York' // Attempt EST/EDT first
        };
        if (includeTime) {
            options.hour = '2-digit';
            options.minute = '2-digit';
            options.second = '2-digit';
            options.hour12 = true;
        }

        let formattedDateTime = new Intl.DateTimeFormat('en-US', options).format(date);

        let timeLooksMissing = includeTime && !formattedDateTime.match(/AM|PM/i) && !formattedDateTime.match(/\d{1,2}:\d{2}:\d{2}/);
        if (formattedDateTime.includes('undefined') || formattedDateTime.includes('GMT') || timeLooksMissing ) {
             delete options.timeZone; // Fallback to browser's local timezone

             // Ensure time options are present if includeTime is true and they seemed missing
             if (includeTime) {
                options.hour = '2-digit';
                options.minute = '2-digit';
                options.second = '2-digit';
                options.hour12 = true;
             } else { // Ensure time options are absent if includeTime is false for the fallback
                delete options.hour;
                delete options.minute;
                delete options.second;
                delete options.hour12;
             }
             formattedDateTime = new Intl.DateTimeFormat('en-US', options).format(date);
        }
        return formattedDateTime;
    } catch (e) {
        console.error("Error formatting date:", e);
        // Basic fallback string
        let day = String(date.getDate()).padStart(2, '0');
        let month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
        let year = date.getFullYear();
        let fallback = `${month}/${day}/${year}`; // MM/DD/YYYY

        if (includeTime) {
            let hours = date.getHours();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // Hour '0' should be '12'
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            fallback += `, ${hours}:${minutes}:${seconds} ${ampm}`;
        }
        return fallback;
    }
}

        function loadKnownPlayersDisplay() {
    let knownPlayerObjects = getStoredData(LS_KNOWN_PLAYERS) || [];

    let migrationOccurred = false;
    const processedObjects = knownPlayerObjects.map(entry => {
        if (typeof entry === 'string') {
            migrationOccurred = true;
            return { id: entry.toLowerCase(), displayName: entry };
        }
        if (entry && typeof entry.id === 'string' && typeof entry.displayName === 'string') {
            if (entry.id !== entry.id.toLowerCase()) {
                migrationOccurred = true;
                return { id: entry.id.toLowerCase(), displayName: entry.displayName };
            }
            return entry;
        }
        migrationOccurred = true;
        return null;
    }).filter(entry => entry !== null);

    if (migrationOccurred) {
        setStoredData(LS_KNOWN_PLAYERS, processedObjects);
        knownPlayerObjects = processedObjects;
    } else {
        knownPlayerObjects = processedObjects;
    }

    knownPlayerObjects.sort((a,b) => a.displayName.localeCompare(b.displayName));

    knownPlayersList.innerHTML = knownPlayerObjects.length === 0 ? '<p class="text-sm text-muted">No players saved yet.</p>' : '';

    knownPlayerObjects.forEach(playerObj => {
        const entryDiv = document.createElement('div');
        // Classes for compact "chip" layout (should match step 1 of previous plan)
        entryDiv.className = 'known-player-entry inline-flex items-center mb-1 mr-2 px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded-md shadow-sm';

        const selectBtn = document.createElement('button');
        // Classes for compact button, text-left. CSS handles text-transform. (should match step 1 of previous plan)
        selectBtn.className = 'btn btn-secondary text-xs py-0 px-1 known-player-select-btn text-left';
        selectBtn.textContent = playerObj.displayName;
        selectBtn.addEventListener('click', () => addKnownPlayerToNewGameSetup(playerObj.displayName));

        const deleteBtn = document.createElement('button');
        // Classes for compact delete button (should match step 1 of previous plan)
        deleteBtn.className = 'btn btn-text-danger text-xs py-0 px-1 known-player-delete-btn flex-shrink-0 ml-1';
        deleteBtn.textContent = 'X';
        deleteBtn.setAttribute('data-player-id', playerObj.id);
        deleteBtn.addEventListener('click', () => handleDeleteKnownPlayer(playerObj.id));

        entryDiv.appendChild(selectBtn);
        entryDiv.appendChild(deleteBtn);
        knownPlayersList.appendChild(entryDiv);
    });
}
        function addKnownPlayerToStorage(name) {
            let known = getStoredData(LS_KNOWN_PLAYERS) || [];
            if (!known.includes(name)) { known.push(name); setStoredData(LS_KNOWN_PLAYERS, known.sort()); loadKnownPlayersDisplay(); }
        }
        function addKnownPlayerToNewGameSetup(name) {
            if (playersForNewGameSetup.find(p => p.name.toLowerCase() === name.toLowerCase())) { alert(`${name} is already in setup.`); return; }
            playersForNewGameSetup.push({ id: String(Date.now() + Math.random()).replace(/\./g, '_'), name: name, scores: [], totalScore: 0, eliminated: false, canReEnterCurrentRound: false, isDealer: false, reEntryCount: 0, reEntryEvents: [] });
            renderNewGameSetupPlayersList();
        }
        function handleAddNewPlayerToSetup() {
            const name = playerNameInput.value.trim();
            if (name) {
                if (playersForNewGameSetup.find(p => p.name.toLowerCase() === name.toLowerCase())) { alert('Player already in setup.'); return; }
                playersForNewGameSetup.push({ id: String(Date.now() + Math.random()).replace(/\./g, '_'), name: name, scores: [], totalScore: 0, eliminated: false, canReEnterCurrentRound: false, isDealer: false, reEntryCount: 0, reEntryEvents: [] });
                addKnownPlayerToStorage(name);
                playerNameInput.value = ''; renderNewGameSetupPlayersList();
            } else { alert('Enter player name.'); }
            playerNameInput.focus();
        }
        function renderNewGameSetupPlayersList() {
    playerSetupList.innerHTML = playersForNewGameSetup.length === 0 ? '<p class="text-sm text-muted">Add players for new game.</p>' : '';
    playersForNewGameSetup.forEach((player) => {
        const div = document.createElement('div');
        // Apply compact "chip" styling classes to the wrapper div
        div.className = 'player-setup-entry inline-flex items-center mb-1 mr-2 px-2 py-1 bg-gray-100 dark:bg-gray-600 rounded-md shadow-sm';

        // Apply compact styling to inner elements
        div.innerHTML =
            `<span class="text-gray-700 dark:text-gray-200 text-sm">${player.name}</span>` +
            `<button class="btn btn-text-danger text-xs py-0 px-1 font-semibold ml-2" data-id="${player.id}">REMOVE</button>`;

        div.querySelector('button').addEventListener('click', (e) => removePlayerFromNewGameSetup(e.target.dataset.id));
        playerSetupList.appendChild(div);
    });
}
        function removePlayerFromNewGameSetup(playerId) {
            playersForNewGameSetup = playersForNewGameSetup.filter(p => p.id !== playerId);
            renderNewGameSetupPlayersList();
        }

        function loadSavedGamesDisplay() {
            const savedGames = getStoredData(LS_SAVED_GAMES_LIST) || [];
            savedGamesContainer.innerHTML = savedGames.length === 0 ? '<p class="text-sm text-muted">No games saved.</p>' : '';
            savedGames.sort((a,b) => new Date(b.lastSavedTimestamp) - new Date(a.lastSavedTimestamp));
            savedGames.forEach(game => {
                const div = document.createElement('div');
                div.className = `saved-game-item p-4 rounded-lg shadow-md flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 ${game.isComplete ? 'completed-game' : ''}`;
                const playerNames = game.players.map(p => p.name).slice(0,3).join(', ') + (game.players.length > 3 ? '...' : '');
                let gameStatusInfo = game.isComplete ? ' (Complete)' : '';
                div.innerHTML = `
                    <div class="flex-grow"><p class="font-semibold game-name-link">${game.name || `Game from ${getFormattedEstDate(new Date(game.lastSavedTimestamp))}`}${gameStatusInfo}</p><p class="text-xs">Players: ${playerNames}</p><p class="text-xs">Round: ${game.currentRound}, Target: ${game.gameTargetScore}</p><p class="text-xs text-muted">Last Saved: ${getFormattedEstDate(new Date(game.lastSavedTimestamp))}</p></div>
                    <div class="flex gap-2 mt-2 sm:mt-0 self-end sm:self-center flex-shrink-0">
                        <button class="btn btn-text-blue text-xs py-1 px-2 edit-name-btn" data-game-id="${game.id}">Edit Name</button>
                        <button class="btn btn-text-green text-xs py-1 px-2 load-game-btn" data-game-id="${game.id}">${game.isComplete ? 'View' : 'Continue'}</button>
                        <button class="btn btn-text-danger text-xs py-1 px-2 delete-game-btn" data-game-id="${game.id}">Delete</button>
                    </div>`;
                div.querySelector('.load-game-btn').addEventListener('click', () => handleLoadGame(game.id));
                div.querySelector('.delete-game-btn').addEventListener('click', () => handleDeleteGame(game.id));
                div.querySelector('.edit-name-btn').addEventListener('click', () => handleEditGameName(game.id));
                savedGamesContainer.appendChild(div);
            });
        }

function handleDeleteKnownPlayer(playerId) {
    // Find the player object to get the displayName for the confirmation message
    const knownPlayersForConfirmation = getStoredData(LS_KNOWN_PLAYERS) || [];
    const playerObjectToDelete = knownPlayersForConfirmation.find(p => p.id === playerId);

    if (!playerObjectToDelete) {
        console.warn("Attempted to delete known player, but ID not found for confirmation:", playerId);
        loadKnownPlayersDisplay(); // Refresh display in case of inconsistency
        return;
    }

    if (confirm(`Are you sure you want to remove "${playerObjectToDelete.displayName}" from the known players list?`)) {
        let knownPlayersObjects = getStoredData(LS_KNOWN_PLAYERS) || [];

        // Robust processing of the list before filtering
        knownPlayersObjects = knownPlayersObjects.map(entry => {
            if (typeof entry === 'string') { return { id: entry.toLowerCase(), displayName: entry }; }
            if (entry && typeof entry.id === 'string' && typeof entry.displayName === 'string') {
                return { id: entry.id.toLowerCase(), displayName: entry.displayName };
            }
            return null;
        }).filter(entry => entry !== null);

        const initialKnownLength = knownPlayersObjects.length;
        const updatedKnownPlayers = knownPlayersObjects.filter(pObj => pObj.id !== playerId);

        if (updatedKnownPlayers.length < initialKnownLength) {
            setStoredData(LS_KNOWN_PLAYERS, updatedKnownPlayers);
        } else {
            console.warn("Known player ID not found for deletion in main list processing:", playerId);
        }

        // Also remove from playersForNewGameSetup if present
        const initialSetupLength = playersForNewGameSetup.length;
        playersForNewGameSetup = playersForNewGameSetup.filter(
            playerInSetup => playerInSetup.name.toLowerCase() !== playerId
        );

        if (playersForNewGameSetup.length < initialSetupLength) {
            renderNewGameSetupPlayersList(); // Refresh the setup list display
        }

        loadKnownPlayersDisplay(); // Refresh the known players list display
    }
}

function showWinnerCelebrationOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'winner-celebration-overlay';

    const numConfetti = 70; // Number of confetti particles
    const numStreamers = 15; // Number of streamers
    const colors = ['color-red', 'color-yellow', 'color-blue', 'color-green', 'color-purple', 'color-orange'];
    const confettiShapes = ['confetti', 'confetti circle'];
    const animationDurations = ['animate-fall-1', 'animate-fall-2', 'animate-fall-3']; // Corresponds to 3s, 4s, 5s

    // Create Confetti
    for (let i = 0; i < numConfetti; i++) {
        const confettiPiece = document.createElement('div');
        const shape = confettiShapes[Math.floor(Math.random() * confettiShapes.length)];
        const color = colors[Math.floor(Math.random() * colors.length)];
        const animClass = animationDurations[Math.floor(Math.random() * animationDurations.length)];

        confettiPiece.className = `particle ${shape} ${color} ${animClass}`;
        confettiPiece.style.left = Math.random() * 100 + 'vw';
        confettiPiece.style.animationDelay = Math.random() * 1.5 + 's';
        confettiPiece.style.transform = `translateX(${(Math.random() * 60) - 30}px) rotate(0deg)`;

        overlay.appendChild(confettiPiece);
    }

    // Create Streamers
    for (let i = 0; i < numStreamers; i++) {
        const streamerPiece = document.createElement('div');
        const color = colors[Math.floor(Math.random() * colors.length)];
        const animClass = animationDurations[1 + Math.floor(Math.random() * (animationDurations.length - 1))];

        streamerPiece.className = `particle streamer ${color} ${animClass}`;
        streamerPiece.style.left = Math.random() * 100 + 'vw';
        streamerPiece.style.animationDelay = Math.random() * 2 + 's';
        streamerPiece.style.transform = `translateX(${(Math.random() * 40) - 20}px) rotate(${(Math.random() * 60) - 30}deg)`;

        overlay.appendChild(streamerPiece);
    }

    document.body.appendChild(overlay);

    setTimeout(() => {
        if (document.body.contains(overlay)) { // Check if overlay still exists before trying to remove
            document.body.removeChild(overlay);
        }
    }, 7000); // Max animation duration (5s) + max animation delay (2s)
}

        function handleDeleteGame(gameId) {
            if (!confirm("Delete this saved game?")) return;
            let savedGames = getStoredData(LS_SAVED_GAMES_LIST) || [];
            savedGames = savedGames.filter(g => String(g.id) !== String(gameId)); 
            setStoredData(LS_SAVED_GAMES_LIST, savedGames);
            loadSavedGamesDisplay();
            if (currentGame && String(currentGame.id) === String(gameId)) { currentGame = null; transitionToSetupView(); } 
        }
         function handleEditGameName(gameId) {
            let savedGames = getStoredData(LS_SAVED_GAMES_LIST) || [];
            const gameIndex = savedGames.findIndex(g => String(g.id) === String(gameId));
            if (gameIndex === -1) { alert("Game not found."); return; }
            const oldName = savedGames[gameIndex].name;
            const newName = prompt("Enter new name:", oldName);
            if (newName && newName.trim() !== "") {
                savedGames[gameIndex].name = newName.trim();
                setStoredData(LS_SAVED_GAMES_LIST, savedGames);
                loadSavedGamesDisplay(); 
                if (currentGame && String(currentGame.id) === String(gameId)) {
                    currentGame.name = newName.trim();
                    currentGameNameDisplay.textContent = currentGame.name; 
                }
            } else if (newName !== null) { alert("Game name cannot be empty.");}
        }
        
function generateDefaultGameName(playersList) {
    const playerNames = (playersList && playersList.length > 0)
        ? playersList.map(p => p.name).slice(0,2).join(' & ')
        : "New Game"; // Fallback if playersList is empty or undefined
    // Call with includeTime = true
    return `Game: ${playerNames} - ${getFormattedEstDate(new Date(), true)}`;
}

function handleStartNewGame() {
    if (playersForNewGameSetup.length < 2) {
        alert('Select at least 2 players to start the game.');
        return;
    }

    // Explicitly clear previous game status message and animation classes
    if (gameStatusMessage) {
        gameStatusMessage.textContent = '';
        gameStatusMessage.classList.remove('winner-message-animate');
    }
    // Clean animation classes from sections to prevent stale animation states
    if (gameSection) {
        gameSection.classList.remove('section-is-entering', 'section-animate-initial', 'section-is-exiting', 'hidden');
    }
    if (setupSection) {
        setupSection.classList.remove('section-is-entering', 'section-animate-initial', 'section-is-exiting', 'hidden');
    }

    // Create a pristine currentGame object
    currentGame = {
        id: null, // Will be set on first auto-save
        name: generateDefaultGameName(playersForNewGameSetup), // Name will be made more unique in a later step
        players: playersForNewGameSetup.map((playerSetupObj, index) => {
            // playerSetupObj is from playersForNewGameSetup, e.g., {id: 'someOriginalId', name: 'PlayerName'}
            // We create a new, clean player object for the game state.
            return {
                id: String(playerSetupObj.id).replace(/\./g, '_'), // Use and sanitize ID from setup
                name: playerSetupObj.name, // Use name from setup
                scores: [],
                totalScore: 0,
                eliminated: false,
                canReEnterCurrentRound: false,
                isDealer: index === 0,
                reEntryCount: 0,
                reEntryEvents: [],
                isWinner: false,      // Explicitly reset
                justEliminated: false // Explicitly reset
            };
        }),
        currentRound: 0,
        gameTargetScore: parseInt(gameTargetScoreInput.value) || 201,
        openDropScore: parseInt(openDropScoreInput.value) || 20,
        middleDropScore: parseInt(middleDropScoreInput.value) || 40,
        fullCountScore: parseInt(fullCountScoreInput.value) || 80,
        lastSavedTimestamp: new Date().toISOString(),
        initialPlayerOrder: playersForNewGameSetup.map(p => String(p.id).replace(/\./g, '_')),
        roundDealerHistory: [],
        isComplete: false,
        justSubmittedNewRound: false // Explicitly reset
    };

    playersForNewGameSetup = []; // Clear the setup list array
    renderNewGameSetupPlayersList(); // Update UI for the now empty setup list

    transitionToGameView();

    autoSaveGameProgress();
}

        function handleLoadGame(gameId) {
            const savedGames = getStoredData(LS_SAVED_GAMES_LIST) || [];
            const gameToLoad = savedGames.find(g => String(g.id) === String(gameId));
            if (gameToLoad) {
                currentGame = JSON.parse(JSON.stringify(gameToLoad));
                currentGame.players.forEach(p => { 
                    p.id = String(p.id).replace(/\./g, '_'); 
                    p.scores = p.scores || [];
                    p.reEntryEvents = p.reEntryEvents || []; 
                    // Recalculate totalScore based on re-entry logic on load
                    let baseScore = 0;
                    let sumFromRoundIndex = 0;
                    if (p.reEntryEvents && p.reEntryEvents.length > 0) {
                        const lastReEntry = p.reEntryEvents[p.reEntryEvents.length - 1];
                        baseScore = lastReEntry.newBaselineScore; 
                        sumFromRoundIndex = lastReEntry.roundIndex; 
                    }
                    let sumOfScoresAfterLastReEntry = 0;
                    for (let i = sumFromRoundIndex; i < p.scores.length; i++) {
                        if (p.scores[i]) { sumOfScoresAfterLastReEntry += p.scores[i].points; }
                    }
                    p.totalScore = baseScore + sumOfScoresAfterLastReEntry;
                    
                    p.eliminated = p.totalScore >= currentGame.gameTargetScore; 
                    if (p.eliminated) p.totalScore = currentGame.gameTargetScore; 
                    p.canReEnterCurrentRound = p.canReEnterCurrentRound || false;
                    p.isDealer = p.isDealer || false;
                    p.reEntryCount = p.reEntryCount || 0;
                });
                if (!currentGame.initialPlayerOrder) currentGame.initialPlayerOrder = currentGame.players.map(p => p.id);
                else currentGame.initialPlayerOrder = currentGame.initialPlayerOrder.map(id => String(id).replace(/\./g, '_')); 
                if (!currentGame.roundDealerHistory) currentGame.roundDealerHistory = [];
                
                const currentDealerPlayer = currentGame.players.find(p => p.isDealer);
                if (!currentDealerPlayer && currentGame.players.filter(p => !p.eliminated).length > 0) {
                    advanceDealer(); 
                } else if (!currentDealerPlayer && currentGame.players.length > 0) {
                    currentGame.players[0].isDealer = true; 
                }
                currentGame.isComplete = currentGame.isComplete || false; 

                gameTargetScoreInput.value = currentGame.gameTargetScore;
                openDropScoreInput.value = currentGame.openDropScore;
                middleDropScoreInput.value = currentGame.middleDropScore;
                fullCountScoreInput.value = currentGame.fullCountScore;
                transitionToGameView();
            } else { alert("Error loading game."); }
        }
        
        function showAutoSaveNotification() {
            autoSaveNotification.classList.add('show');
            setTimeout(() => { autoSaveNotification.classList.remove('show'); }, 2000); 
        }

        function autoSaveGameProgress() { 
            if (!currentGame) return; 
            let savedGames = getStoredData(LS_SAVED_GAMES_LIST) || [];
            currentGame.lastSavedTimestamp = new Date().toISOString();
            if (!currentGame.id) { 
                currentGame.id = String(Date.now()).replace(/\./g, '_'); 
                // Game name is set in handleStartNewGame
                savedGames.push(JSON.parse(JSON.stringify(currentGame)));
            } else { 
                const gameIndex = savedGames.findIndex(g => String(g.id) === String(currentGame.id));
                if (gameIndex > -1) savedGames[gameIndex] = JSON.parse(JSON.stringify(currentGame));
                else savedGames.push(JSON.parse(JSON.stringify(currentGame))); 
            }
            setStoredData(LS_SAVED_GAMES_LIST, savedGames);
            loadSavedGamesDisplay(); 
            if(currentGameNameDisplay) currentGameNameDisplay.textContent = currentGame.name; 
            showAutoSaveNotification();
        }
        
function transitionToGameView() {
    if (!currentGame) return;

    // Start exiting setupSection
    if (setupSection) {
        // Clean up any existing animation classes on setupSection first
        setupSection.classList.remove('section-is-entering', 'section-animate-initial');
        setupSection.classList.add('section-is-exiting');
    }

    // After exit animation, switch visibility and start entering gameSection
    setTimeout(() => {
        if (setupSection) {
            setupSection.classList.add('hidden');
            setupSection.classList.remove('section-is-exiting');
        }

        if (gameSection) {
            // Prepare gameSection for entry animation
            gameSection.classList.remove('hidden');
            // Clean up any existing animation classes on gameSection first
            gameSection.classList.remove('section-is-exiting');
            gameSection.classList.add('section-animate-initial');

            // Force a reflow to ensure initial state is applied before animation
            void gameSection.offsetHeight;

            gameSection.classList.add('section-is-entering');

            // Explicitly update all game-specific display elements from currentGame
            if(appTitle) appTitle.classList.add('navigable');

            if(currentGameNameDisplay) {
                currentGameNameDisplay.textContent = currentGame.name || "Scoreboard";
            }
            if(currentRoundDisplay) {
                currentRoundDisplay.textContent = currentGame.currentRound;
            }
            if(gameTargetScoreDisplay) {
                gameTargetScoreDisplay.textContent = currentGame.gameTargetScore;
            }
            if(gameOpenDropDisplay) {
                gameOpenDropDisplay.textContent = currentGame.openDropScore;
            }
            if(gameMiddleDropDisplay) {
                gameMiddleDropDisplay.textContent = currentGame.middleDropScore;
            }
            if(gameFullCountDisplay) {
                gameFullCountDisplay.textContent = currentGame.fullCountScore;
            }

            // gameStatusMessage is usually set by checkGameEnd (called via renderRoundScoresTable).
            // If it's a brand new game (round 0, no player has scores), ensure message is clear.
            // handleStartNewGame also clears it, this is an additional safeguard.
            let isBrandNewGame = currentGame.currentRound === 0 && currentGame.players.every(p => p.scores.length === 0);
            if (isBrandNewGame && gameStatusMessage) {
                 gameStatusMessage.textContent = '';
                 gameStatusMessage.classList.remove('winner-message-animate'); // Also clear animation
            }

            renderRoundScoresTable(); // This will build the table based on new currentGame

            // After entry animation, clean up animation classes from gameSection
            setTimeout(() => {
                if (gameSection) {
                    gameSection.classList.remove('section-is-entering');
                    gameSection.classList.remove('section-animate-initial');
                }
            }, 300); // This duration should match the CSS transition duration
        }
    }, 300); // This duration should match the CSS transition duration
}
        
function transitionToSetupView() {
    console.log("Transitioning to setup view...");

    // 1. Start exiting gameSection
    if (gameSection) {
        gameSection.classList.add('section-is-exiting');
    }

    // 2. After exit animation, switch visibility and start entering setupSection
    setTimeout(() => {
        if (gameSection) {
            gameSection.classList.add('hidden');
            gameSection.classList.remove('section-is-exiting'); // Clean up
        }

        if (setupSection) {
            // Prepare setupSection for entry animation
            setupSection.classList.remove('hidden');
            setupSection.classList.add('section-animate-initial');

            // Force a reflow
            void setupSection.offsetHeight;

            setupSection.classList.add('section-is-entering');

            // Original logic to populate/reset setup view data:
            if(appTitle) appTitle.classList.remove('navigable'); 
            loadSavedGamesDisplay();
            loadKnownPlayersDisplay();
            renderNewGameSetupPlayersList();

            // Debug logs from original, can be kept or removed
            // if(gameSection) console.log("Game section hidden:", gameSection.classList.contains('hidden'));
            // if(setupSection) console.log("Setup section visible:", !setupSection.classList.contains('hidden'));

            // 3. After entry animation, clean up animation classes from setupSection
            setTimeout(() => {
                if (setupSection) {
                    setupSection.classList.remove('section-is-entering');
                    setupSection.classList.remove('section-animate-initial');
                }
            }, 300); // This duration should match the CSS transition duration
        }
    }, 300); // This duration should match the CSS transition duration
}

        function renderRoundScoresTable() {
            if (!currentGame || currentGame.players.length === 0) {
                if(roundScoresTableContainer) roundScoresTableContainer.innerHTML = '<p class="text-sm text-muted">No rounds played yet or no players.</p>'; return;
            }

            const highlightNewRound = currentGame.justSubmittedNewRound;
            if (highlightNewRound) {
                currentGame.justSubmittedNewRound = false; // Reset flag
            }

            let tableHTML = '<table class="min-w-full divide-y shadow-sm rounded-lg overflow-hidden"><thead><tr>';
            tableHTML += '<th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider">Round</th>';
            currentGame.players.forEach(player => {
                let dealerMark = player.isDealer ? '<span class="text-xs text-muted">(D)</span>' : '';
                tableHTML += `<th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider">${player.name} ${dealerMark}</th>`;
            });
            tableHTML += '</tr></thead><tbody class="divide-y">';
            for (let i = 0; i < currentGame.currentRound; i++) {
                let trAttributes = "";
                if (highlightNewRound && i === (currentGame.currentRound - 1)) {
                    trAttributes = " class='new-score-row-highlight'";
                }
                tableHTML += `<tr${trAttributes}><td class="px-4 py-3 whitespace-nowrap text-sm font-medium">Round ${i + 1}</td>`;
                currentGame.players.forEach(player => {
                    const scoreItem = player.scores[i];
                    let scoreDisplay = '-';
                    if (scoreItem !== undefined) {
                        scoreDisplay = `${scoreItem.points}`;
                        if (scoreItem.points === 0) scoreDisplay += " 🎉";
                        if (scoreItem.type === 'OD') scoreDisplay += " (OD)";
                        else if (scoreItem.type === 'MD') scoreDisplay += " (MD)";
                        else if (scoreItem.type === 'FC') scoreDisplay += " (FC)";
                    }
                    tableHTML += `<td class="px-4 py-3 whitespace-nowrap text-sm">${scoreDisplay}</td>`;
                });
                tableHTML += '</tr>';
            }
            tableHTML += '</tbody><tfoot><tr class="border-t-2 dark:border-gray-600">';
            tableHTML += '<td class="px-4 py-3 text-sm font-semibold">Current Status</td>';
            currentGame.players.forEach(player => {
                let statusText = `${player.totalScore}`; // Base score

                if (player.eliminated) {
                    statusText += ' (Out)';
                    // Only show re-entry count if they are currently eliminated AND have re-entered
                    if (player.reEntryCount > 0) {
                       statusText += ` (Re-entered ${player.reEntryCount} time${player.reEntryCount > 1 ? 's' : ''})`;
                    }
                    // Show re-enter button if they are eliminated AND can re-enter this round
                    if (player.canReEnterCurrentRound) { 
                        statusText += ` <button class="btn btn-warning text-xs py-0.5 px-1 re-enter-btn" data-player-id="${player.id}">Re-enter</button>`;
                    }
                }
                // If player is not eliminated, no "(Out)" text, no re-entry count text, and no re-enter button will be added here.
                let tdClasses = "px-4 py-3 text-sm font-semibold"; // Original classes for the cell

                if (player.justEliminated) {
                    tdClasses += " player-just-eliminated-animation";
                    player.justEliminated = false; // Reset flag after use
                } else if (player.isWinner === true) { // Check if the player is the winner
                    tdClasses += " winner-highlight-cell";
                    // player.isWinner is a persistent flag for this game state, not reset here
                }
                tableHTML += `<td class="${tdClasses}">${statusText}</td>`;
            });
            tableHTML += '</tr></tfoot></table>';
            if(roundScoresTableContainer) roundScoresTableContainer.innerHTML = tableHTML;
            if(roundScoresTableContainer) roundScoresTableContainer.querySelectorAll('.re-enter-btn').forEach(btn => btn.addEventListener('click', (e) => handleReEnterGame(e.target.dataset.playerId)));
            checkGameEnd(); 
        }
        
        function handleReEnterGame(playerId) {
            if (!currentGame) return;
            const playerToReEnter = currentGame.players.find(p => String(p.id) === String(playerId));
            
            if (playerToReEnter && playerToReEnter.eliminated && playerToReEnter.canReEnterCurrentRound) {
                let highestScoreOfOthers = 0;
                const scoresOfOtherPlayers = currentGame.players.filter(p => p.id !== playerToReEnter.id).map(p => p.totalScore);
                if (scoresOfOtherPlayers.length > 0) {
                    highestScoreOfOthers = Math.max(0, ...scoresOfOtherPlayers);
                }

                const newBaselineScore = highestScoreOfOthers + 1;
                
                playerToReEnter.totalScore = newBaselineScore; 
                playerToReEnter.eliminated = false;
                playerToReEnter.canReEnterCurrentRound = false; 
                playerToReEnter.reEntryCount = (playerToReEnter.reEntryCount || 0) + 1;
                
                if (!playerToReEnter.reEntryEvents) playerToReEnter.reEntryEvents = [];
                playerToReEnter.reEntryEvents.push({ roundIndex: playerToReEnter.scores.length, newBaselineScore: newBaselineScore }); 

                currentGame.isComplete = false; 
                if(gameStatusMessage) gameStatusMessage.textContent = ''; 
                
                renderRoundScoresTable(); 
                autoSaveGameProgress();
                alert(`${playerToReEnter.name} re-entered (Count: ${playerToReEnter.reEntryCount}) at ${playerToReEnter.totalScore}.`);
                checkGameEnd(); 
            }
        }

        function openScoreModal(isEditing = false, roundToEdit = -1) {
            isEditingLastRoundGlobal = isEditing; 
            if (!currentGame || (!isGameEffectivelyActive() && !isEditing && !(currentGame && currentGame.isComplete && isEditing))) { 
                if(gameStatusMessage && gameStatusMessage.textContent === '' && !isEditing && !(currentGame && currentGame.isComplete)) alert("Game seems to be over or not properly started.");
                else if (currentGame && currentGame.isComplete && !isEditing) alert("This game is complete. Start a new game or load another.");
                return;
            }
            const roundNumberForModal = isEditing ? roundToEdit : currentGame.currentRound + 1;
            scoreModalTitle.innerHTML = `${isEditing ? 'Edit Scores for' : 'Enter Scores for'} Round <span id="modalRoundNumber">${roundNumberForModal}</span>`;
            modalScoreInputs.innerHTML = ''; 
            currentGame.players.forEach(player => {
                if (!isEditing && player.eliminated) return; 
                const inputGroup = document.createElement('div');
                inputGroup.className = 'player-score-entry border p-4 rounded-md shadow-sm'; 
                let dealerMarkForModal = '';
                if ((isEditing && currentGame.roundDealerHistory && currentGame.roundDealerHistory[roundToEdit - 1] === player.id) || (!isEditing && player.isDealer)) {
                    dealerMarkForModal = '<span class="text-sm text-blue-500 dark:text-sky-400">(Dealer)</span>';
                }
                inputGroup.innerHTML = `
                    <label class="block text-md font-medium mb-2">${player.name} ${dealerMarkForModal}:</label>
                    <div class="grid grid-cols-4 gap-1 mb-3">
                        <button class="btn score-option-btn" data-score="0" data-type="win">Win (0)</button>
                        <button class="btn score-option-btn" data-score="${currentGame.openDropScore}" data-type="OD">Open (${currentGame.openDropScore})</button>
                        <button class="btn score-option-btn" data-score="${currentGame.middleDropScore}" data-type="MD">Mid (${currentGame.middleDropScore})</button>
                        <button class="btn score-option-btn" data-score="${currentGame.fullCountScore}" data-type="FC">Full (${currentGame.fullCountScore})</button>
                    </div>
                    <input type="number" id="score-input-${player.id}" placeholder="Or enter score manually">
                    <input type="hidden" id="score-type-${player.id}" value="manual">`; 
                const scoreInputElement = inputGroup.querySelector(`#score-input-${player.id}`);
                const scoreTypeElement = inputGroup.querySelector(`#score-type-${player.id}`);
                if (isEditing && player.scores[roundToEdit - 1] !== undefined) {
                    const scoreItem = player.scores[roundToEdit - 1];
                    scoreInputElement.value = scoreItem.points;
                    scoreTypeElement.value = scoreItem.type;
                }
                scoreInputElement.addEventListener('input', () => { scoreTypeElement.value = 'manual'; });
                inputGroup.querySelectorAll('.score-option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        scoreInputElement.value = btn.dataset.score;
                        scoreTypeElement.value = btn.dataset.type;
                    });
                });
                modalScoreInputs.appendChild(inputGroup);
            });
            scoreModal.classList.add('active');
            const firstInput = modalScoreInputs.querySelector('input[type="number"]');
            if (firstInput) firstInput.focus();
        }

function handleSubmitScores() {
    if (!currentGame) return;

    let playersWithErrors = [];
    let allScoresValid = true;
    let zeroScoreCount = 0;
    const roundScoresData = [];

    const roundIndexBeingProcessed = isEditingLastRoundGlobal ? currentGame.currentRound - 1 : currentGame.currentRound;

    const playerStatesBeforeThisRound = currentGame.players.map(p => ({
        id: p.id,
        wasEliminated: p.eliminated,
    }));

    currentGame.players.forEach(player => {
        if (!isEditingLastRoundGlobal && player.eliminated) {
            // For new rounds, if player already eliminated, don't process score input.
            // Their canReEnterCurrentRound was already set to false at start of this loop in earlier versions,
            // ensure this state is handled (e.g. they aren't in playersWithErrors).
            // This 'return' means they are skipped for score validation for this new round.
            return;
        }

        const inputElement = document.getElementById(`score-input-${player.id}`);
        const typeElement = document.getElementById(`score-type-${player.id}`);

        // If editing, an eliminated player might not have an inputElement if openScoreModal skipped them.
        // We should use their existing score for the round being edited if it exists.
        if (!inputElement && isEditingLastRoundGlobal && player.scores && player.scores[roundIndexBeingProcessed] !== undefined) {
            const existingScoreData = player.scores[roundIndexBeingProcessed];
            if (existingScoreData.points === 0) zeroScoreCount++;
            roundScoresData.push({
                playerId: player.id,
                points: existingScoreData.points,
                type: existingScoreData.type
            });
            return; // Move to next player
        }

        // If inputElement is still not found for a player who should have one (active, or editing their score)
        // This implies an issue with openScoreModal or player state if they should be scorable.
        // For now, if no input element and no existing score to use (above), it will be caught by blank score check.
        // Or, more directly, consider it an error if inputElement is null for someone not covered by above.
        if (!inputElement) {
            // This case needs careful consideration: if a player is part of the round but no input field for them.
            // This might happen if an eliminated player is part of an *edited* round but openScoreModal didn't create inputs for them.
            // The current openScoreModal *does* create inputs for all players if isEditing.
            // So, if !inputElement here, it's likely a player who shouldn't be scored or an error.
            // Let's assume for now that players who should be scored will have an inputElement.
            // If not, the scoreValue will be effectively blank.
        }

        const scoreValue = inputElement ? inputElement.value.trim() : ""; // Default to blank if no input
        const scoreType = typeElement ? typeElement.value : 'manual';

        if (scoreValue === '') {
            // Only add error if player is not eliminated (or if editing, consider all players in round)
            // The initial check `!isEditingLastRoundGlobal && player.eliminated` handles skipping already eliminated players for new rounds.
            // So, if we reach here, the player is either active, or we are editing.
            playersWithErrors.push({ name: player.name, issue: "score is blank" });
            allScoresValid = false;
            return;
        }
        const points = parseInt(scoreValue);
        if (isNaN(points)) {
            playersWithErrors.push({ name: player.name, issue: "score is not a valid number" });
            allScoresValid = false;
            return;
        }

        if (points !== 0 && points < 2) {
            playersWithErrors.push({ name: player.name, issue: `score of ${points} is too low (min 2, or 0 for winner)`});
            allScoresValid = false;
            return;
        }
        if (points > currentGame.fullCountScore) {
            playersWithErrors.push({ name: player.name, issue: `score of ${points} is too high (max ${currentGame.fullCountScore})`});
            allScoresValid = false;
            return;
        }

        if (points === 0) zeroScoreCount++;
        roundScoresData.push({ playerId: player.id, points: points, type: scoreType });
    });

    if (!allScoresValid) {
        let errorMessage = "Please correct the following score entries:\n";
        playersWithErrors.forEach(err => {
            errorMessage += `\n- ${err.name}: ${err.issue}.`;
        });
        errorMessage += `\n\nScores must be numbers. Minimum score is 2 (unless 0 for the round winner). Maximum score is ${currentGame.fullCountScore}.`;
        alert(errorMessage);

        if (playersWithErrors.length > 0) {
           const firstPlayerNameWithError = playersWithErrors[0].name;
           const firstPlayerWithError = currentGame.players.find(p => p.name === firstPlayerNameWithError);
           if (firstPlayerWithError) {
               const M_inputElement = document.getElementById(`score-input-${firstPlayerWithError.id}`);
                if(M_inputElement) M_inputElement.focus();
           }
        }
        return;
    }

    if (zeroScoreCount !== 1) {
        alert("Exactly one player must have 0 points for winning the round.");
        return;
    }

    // Apply scores (new or edited)
    if (isEditingLastRoundGlobal) {
        roundScoresData.forEach(rs => {
            const player = currentGame.players.find(p => p.id === rs.playerId);
            if (player && player.scores && player.scores[roundIndexBeingProcessed] !== undefined) {
                player.scores[roundIndexBeingProcessed] = { points: rs.points, type: rs.type };
            }
            // Not handling case where player has no score for roundIndexBeingProcessed during edit,
            // as openScoreModal should provide inputs for all players involved in an edited round.
        });
    } else { // New round
        if (!currentGame.roundDealerHistory) currentGame.roundDealerHistory = [];
        const currentDealer = currentGame.players.find(p => p.isDealer);
        currentGame.roundDealerHistory[currentGame.currentRound] = currentDealer ? currentDealer.id : null;
        roundScoresData.forEach(rs => {
            const player = currentGame.players.find(p => p.id === rs.playerId);
            if (player) player.scores.push({ points: rs.points, type: rs.type });
        });
    }

    // Recalculate totals and statuses (Copied from a previously verified version)
    const provisionalPlayerStates = currentGame.players.map(p => {
        const playerOriginalState = playerStatesBeforeThisRound.find(ps => ps.id === p.id);
        let provisionalTotalScore;
        let baseScore = 0;
        let sumFromRoundIndex = 0;
        if (p.reEntryEvents && p.reEntryEvents.length > 0) {
            const lastReEntry = p.reEntryEvents[p.reEntryEvents.length - 1];
            baseScore = lastReEntry.newBaselineScore;
            sumFromRoundIndex = lastReEntry.roundIndex;
        }
        let sumOfScoresAfterLastReEntry = 0;
        for (let i = sumFromRoundIndex; i < p.scores.length; i++) {
            if (p.scores[i] && typeof p.scores[i].points === 'number') {
                 sumOfScoresAfterLastReEntry += p.scores[i].points;
            }
        }
        provisionalTotalScore = baseScore + sumOfScoresAfterLastReEntry;
        let provisionalEliminated = provisionalTotalScore >= currentGame.gameTargetScore;
        if(provisionalEliminated) provisionalTotalScore = currentGame.gameTargetScore;
        return {
            id: p.id, name: p.name, provisionalTotalScore, provisionalEliminated,
            wasPreviouslyEliminated: playerOriginalState ? playerOriginalState.wasEliminated : false
        };
    });

    let preventReEntryDueToGameEnd = false;
    const activeProvisionalPlayers = provisionalPlayerStates.filter(p => !p.provisionalEliminated);
    if (currentGame.players.length >= 2 && activeProvisionalPlayers.length === 1) {
        preventReEntryDueToGameEnd = true;
    }

    currentGame.players.forEach(player => {
        const provisionalState = provisionalPlayerStates.find(p => p.id === player.id);
        if (!provisionalState) return;
        player.totalScore = provisionalState.provisionalTotalScore;
        player.eliminated = provisionalState.provisionalEliminated;
        player.justEliminated = false;
        if (player.eliminated && provisionalState && !provisionalState.wasPreviouslyEliminated) {
            player.justEliminated = true;
        }
        player.canReEnterCurrentRound = false;
        if (preventReEntryDueToGameEnd) {
            // No re-entry if game provisionally ends
        } else {
            let conditionForReEntryCheck = false;
            if (isEditingLastRoundGlobal) {
                conditionForReEntryCheck = player.eliminated;
            } else {
                conditionForReEntryCheck = player.eliminated && !provisionalState.wasPreviouslyEliminated;
            }
            if (conditionForReEntryCheck) {
                if (currentGame.players.length > 2) {
                    const scoresOfEligibleOthersForReEntry = provisionalPlayerStates
                        .filter(p_check => p_check.id !== player.id && p_check.provisionalTotalScore < currentGame.gameTargetScore)
                        .map(p_check => p_check.provisionalTotalScore);
                    let highestScoreOfEligibleOthers = 0;
                    if (scoresOfEligibleOthersForReEntry.length > 0) {
                        highestScoreOfEligibleOthers = Math.max(0, ...scoresOfEligibleOthersForReEntry);
                    }
                    const potentialReEntryScore = highestScoreOfEligibleOthers + 1;
                    if (potentialReEntryScore < currentGame.gameTargetScore) {
                        const otherActiveProvPlayers = provisionalPlayerStates.filter(p_check =>
                            p_check.id !== player.id && !p_check.provisionalEliminated);
                        if (otherActiveProvPlayers.length >= 1) {
                            player.canReEnterCurrentRound = true;
                        }
                    }
                }
            }
        }
    });

    if (!isEditingLastRoundGlobal) {
        currentGame.currentRound++;
        advanceDealer();
        currentGame.justSubmittedNewRound = true;
    }

    currentRoundDisplay.textContent = currentGame.currentRound;
    renderRoundScoresTable();
    scoreModal.classList.remove('active');
    isEditingLastRoundGlobal = false;
    autoSaveGameProgress();
}
        
        function advanceDealer() {
            if (!currentGame || currentGame.players.length === 0) return;
            if (!currentGame.initialPlayerOrder || currentGame.initialPlayerOrder.length === 0) {
                currentGame.initialPlayerOrder = currentGame.players.map(p => p.id);
            }
            const currentDealerPlayer = currentGame.players.find(p => p.isDealer);
            let currentDealerOriginalIndex = -1;
            if (currentDealerPlayer) {
                currentDealerOriginalIndex = currentGame.initialPlayerOrder.indexOf(currentDealerPlayer.id);
                 if (currentDealerOriginalIndex === -1) { 
                    const idxInCurrentPlayers = currentGame.players.indexOf(currentDealerPlayer);
                    currentDealerOriginalIndex = idxInCurrentPlayers !== -1 ? idxInCurrentPlayers % currentGame.initialPlayerOrder.length : -1;
                }
            }
            currentGame.players.forEach(p => p.isDealer = false);
            let nextDealerIndex = (currentDealerOriginalIndex + 1) % currentGame.initialPlayerOrder.length;
            let attempts = 0;
            while (attempts < currentGame.initialPlayerOrder.length) {
                const nextPotentialDealerId = currentGame.initialPlayerOrder[nextDealerIndex];
                const nextPotentialDealer = currentGame.players.find(p => p.id === nextPotentialDealerId);
                if (nextPotentialDealer && !nextPotentialDealer.eliminated) {
                    nextPotentialDealer.isDealer = true; return;
                }
                nextDealerIndex = (nextDealerIndex + 1) % currentGame.initialPlayerOrder.length;
                attempts++;
            }
            const activePlayers = currentGame.players.filter(p => !p.eliminated);
            if (activePlayers.length > 0) activePlayers[0].isDealer = true;
        }

        function handleEditLastRoundScores() {
            if (!currentGame || currentGame.currentRound === 0) { alert("No completed round to edit."); return; }
            openScoreModal(true, currentGame.currentRound); 
        }

        function checkGameEnd() { 
            if (!currentGame) return;
            const activePlayers = currentGame.players.filter(p => !p.eliminated);
            let gameHasEnded = false;
            currentGame.isComplete = false; 

            // At the beginning of checkGameEnd, or after currentGame.isComplete is reset
            if (currentGame && currentGame.players) { // Ensure currentGame and players exist
                currentGame.players.forEach(player => {
                    player.isWinner = false; // Reset for all players
                });
            }

            const anyPlayerCanReEnter = currentGame.players.some(p => p.eliminated && p.canReEnterCurrentRound);

            if (currentGame.players.length > 0 && activePlayers.length === 0 && !anyPlayerCanReEnter) {
                gameStatusMessage.textContent = "All players eliminated! Game Over."; gameHasEnded = true;
                currentGame.isComplete = true;
            } else if (currentGame.players.length >= 2 && activePlayers.length === 1 && currentGame.currentRound > 0 && !anyPlayerCanReEnter) { 
                gameStatusMessage.textContent = `${activePlayers[0].name} is the winner!`;

                // Set isWinner flag on the winning player object
                if (activePlayers[0]) { // Ensure winner exists
                    const winningPlayerId = activePlayers[0].id;
                    const actualWinningPlayer = currentGame.players.find(p => p.id === winningPlayerId);
                    if (actualWinningPlayer) {
                        actualWinningPlayer.isWinner = true;
                    }
                }

                // Apply animation to gameStatusMessage
                if (gameStatusMessage) {
                    gameStatusMessage.classList.remove('winner-message-animate'); // Remove if already there, to allow re-animation
                    // Force reflow to restart animation if class is re-added
                    void gameStatusMessage.offsetWidth;
                    gameStatusMessage.classList.add('winner-message-animate');
                }
                showWinnerCelebrationOverlay();
                gameHasEnded = true;
                currentGame.isComplete = true;
            }
            
            enterScoresButton.disabled = gameHasEnded || !isGameEffectivelyActive();
            editLastRoundButton.disabled = currentGame.currentRound === 0; 

            if (gameHasEnded) {
                 autoSaveGameProgress(); 
            } else {
                if (anyPlayerCanReEnter) {
                    gameStatusMessage.textContent = 'Some players are eligible for re-entry.';
                } else {
                    if (gameStatusMessage.textContent.includes('eligible for re-entry') || gameStatusMessage.textContent.includes('winner') || gameStatusMessage.textContent.includes('Game Over')) {
                         gameStatusMessage.textContent = ''; 
                    }
                }
            }
        }
        
        function isGameEffectivelyActive() {
            if (!currentGame) return false;
            const activePlayers = currentGame.players.filter(p => !p.eliminated);
            if (activePlayers.length === 0 && currentGame.players.length > 0) return false; 
            if (currentGame.players.length >= 2 && activePlayers.length < 2 ) {
                const canAnyoneReEnter = currentGame.players.some(p => p.eliminated && p.canReEnterCurrentRound);
                if (canAnyoneReEnter) return true; 
                return false;
            }
            return true;
        }

        function handleHomeNavigation() { 
            console.log("App title clicked, handleHomeNavigation called.");
            if (currentGame) { 
                console.log("Auto-saving game before going home...");
                autoSaveGameProgress(); 
            }
            transitionToSetupView();
        }
        
        // handleSuggestName is removed as the button was removed. Auto-suggestion on new game start.

        function initializeApp() {
            appTitle = document.getElementById('appTitle');
            setupSection = document.getElementById('setupSection');
            gameSection = document.getElementById('gameSection');
            playerNameInput = document.getElementById('playerNameInput');
            addPlayerButton = document.getElementById('addPlayerButton');
            knownPlayersList = document.getElementById('knownPlayersList');
            playerSetupList = document.getElementById('playerSetupList');
            gameTargetScoreInput = document.getElementById('gameTargetScoreInput');
            openDropScoreInput = document.getElementById('openDropScoreInput');
            middleDropScoreInput = document.getElementById('middleDropScoreInput');
            fullCountScoreInput = document.getElementById('fullCountScoreInput');
            startNewGameButton = document.getElementById('startNewGameButton');
            savedGamesContainer = document.getElementById('savedGamesContainer');
            themeToggleButton = document.getElementById('themeToggle');
            currentGameNameDisplay = document.getElementById('currentGameNameDisplay');
            nameSuggestionLoader = document.getElementById('nameSuggestionLoader'); 
            currentRoundDisplay = document.getElementById('currentRoundDisplay');
            gameTargetScoreDisplay = document.getElementById('gameTargetScoreDisplay');
            gameOpenDropDisplay = document.getElementById('gameOpenDropDisplay');
            gameMiddleDropDisplay = document.getElementById('gameMiddleDropDisplay');
            gameFullCountDisplay = document.getElementById('gameFullCountDisplay');
            roundScoresTableContainer = document.getElementById('roundScoresTableContainer');
            enterScoresButton = document.getElementById('enterScoresButton');
            editLastRoundButton = document.getElementById('editLastRoundButton');
            gameStatusMessage = document.getElementById('gameStatusMessage');
            autoSaveNotification = document.getElementById('autoSaveNotification');
            scoreModal = document.getElementById('scoreModal');
            scoreModalTitle = document.getElementById('scoreModalTitle');
            modalRoundNumber = document.getElementById('modalRoundNumber');
            modalScoreInputs = document.getElementById('modalScoreInputs');
            submitScoresButton = document.getElementById('submitScoresButton');
            cancelScoreEntryButton = document.getElementById('cancelScoreEntryButton');

            addPlayerButton.addEventListener('click', handleAddNewPlayerToSetup);
            playerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddNewPlayerToSetup(); });
            startNewGameButton.addEventListener('click', handleStartNewGame);
            enterScoresButton.addEventListener('click', () => openScoreModal(false)); 
            editLastRoundButton.addEventListener('click', handleEditLastRoundScores); 
            
            if(appTitle) appTitle.addEventListener('click', handleHomeNavigation); 
            
            submitScoresButton.addEventListener('click', handleSubmitScores);
            cancelScoreEntryButton.addEventListener('click', () => {
                scoreModal.classList.remove('active');
                isEditingLastRoundGlobal = false; 
            });
            themeToggleButton.addEventListener('click', toggleTheme);
            
            // Suggest name button was removed, auto-suggest on new game start via fetchAndSetInitialGameName
            // const suggestNameBtnElement = document.getElementById('suggestNameButton'); 
            // if(suggestNameBtnElement) suggestNameBtnElement.addEventListener('click', () => {
            //    if(currentGame) fetchAndSetInitialGameName(currentGame); 
            // });


            loadTheme(); loadKnownPlayersDisplay(); loadSavedGamesDisplay(); renderNewGameSetupPlayersList();
        }
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
